
set t_Co=256
set background=light
"----------------------------------------------
" https://gist.github.com/yasith/1508312
" fix the solarized scheme issue in Terminal
if !has('gui_running')
  let g:solarized_termcolors=&t_Co
  let g:solarized_termtrans=1
endif
"----------------------------------------------
colorscheme PaperColor
"colorscheme solarized 
"colorscheme haskellcolor 
syntax enable
hi search ctermbg=Gray ctermfg=Brown

"highlight Cursor guifg=white guibg=black
"highlight iCursor guifg=white guibg=green
"set guicursor=n-v-c:block-Cursor
"set guicursor+=i:ver100-iCursor
"set guicursor+=n-v-c:blinkon0
"set guicursor+=i:blinkwait10

"=====================================================================
" You can define up to nine highlight groups to control which color are used
hi User1 ctermbg=white ctermfg=brown   guibg=white guifg=brown
hi User2 ctermbg=black ctermfg=white guibg=black guifg=white
hi User3 ctermbg=blue  ctermfg=green guibg=blue  guifg=green
hi User4 ctermbg=brown  ctermfg=white guibg=white  guifg=black
hi User5 ctermbg=yellow  ctermfg=red guibg=black  guifg=green
hi User6 ctermbg=gray ctermfg=blue guibg=gray guifg=blue

set laststatus=2
set statusline=      " reset
"set statusline+=%f   " file name
"set statusline+=%20((%F)%) " line,column no 

set statusline+=%1*
set statusline+=%0{expand('%:p:t')} " file name 

set statusline+=%2*
set statusline+=%4.20n " buf no

set statusline+=%3*
set statusline+=%3.3m " buf no
set statusline+=%4*
set statusline+=%8.10((%l,%c)%) " line,column no 
set statusline+=%5*
set statusline+=[%10.20{GitBranch()}] " line,column no 
set statusline+=%6*
set statusline+=%30{expand('%:p:h')} " file path 
"=====================================================================
set hls
set omnifunc=csscomplete#CompleteCSS
set autoindent
set nocp
set ruler
set tabstop=4
set shiftwidth=4
set expandtab
set showcmd
set nobackup
set nowritebackup
set noswapfile 
set autochdir
set backspace=2
set dictionary=/home/user/.vim/myword/myword.txt


set pastetoggle=<F4>
"map <F9> :call IncreaseColor() <CR>
map <F10> :call MapKey() <CR>


map ,nl :.,$s/\S.*\S/\0<br>/gc <bar> :nohlsearch <CR>
map ,n :nohlsearch <CR>
map ,w :w!<CR>
map ,l :.,.s/\S.*\S$/\\[ \0 \\]/gc <bar> :nohlsearch <CR>
map ,, :.,$s/\S.*\S/\0\<br>/gc <bar> :nohlsearch <CR>
imap ,w OQ  :w! <CR>

map ,l :.,.s/\S.*\S$/\\[ \0 \\]/gc <bar> :nohlsearch <CR>

imap ,nl :.,.s/^\S.*$/\0<br>/gc <bar> :nohlsearch <CR>
imap ,w OQ  :w! <CR>
cabbr sv :source ~/.vimrc
autocmd FileType tex iabbr cc \mathbb{C}
autocmd FileType tex iabbr qq \mathbb{Q}
autocmd FileType tex iabbr nn \mathbb{N}
autocmd FileType tex iabbr rr \mathbb{R}
autocmd FileType tex iabbr gro $(\mathbb{N}, +)$
autocmd FileType tex iabbr grtau $\Huge \color{red}\tau$ 
autocmd FileType tex iabbr lmapq $\phi: \mathbb{Q} \rightarrow \mathbb{Q}$  
autocmd FileType tex iabbr lmapr $\phi: \polyringr{x} \rightarrow  \polyringr{x}$ 
autocmd FileType tex iabbr lmapn $\phi: \polyringn{x} \rightarrow  \polyringn{x}$ 
autocmd FileType tex iabbr lmapc $\phi: \mathbb{C} \rightarrow \mathbb{C}$  
autocmd FileType tex iabbr ma \begin{bmatrix}<CR>1 & 2  & 3 \\<CR>4 & 5  & 6 \\<CR>7 & 8  & 9 \\<CR>\end{bmatrix}
autocmd FileType tex iabbr ee [\  \]
autocmd FileType tex iabbr txx \text{}
autocmd FileType tex iabbr fraa \frac{}{}


autocmd BufRead *.java map <F9> :call CompileJava()<CR>
autocmd BufRead *.hs   map <F9> :call CompileHaskell()<CR>

" Vim file
autocmd BufRead *.vim,*.vimrc vnoremap <buffer><localleader>c :s/^\s*\zs\w/"\0/g <bar> :nohlsearch  <CR>
autocmd BufRead *.vim,*.vimrc vnoremap <buffer><localleader>i :s/^"//g <bar> :nohlsearch <CR>

" Haskell
autocmd BufRead *.hs vnoremap <buffer><localleader>c :s/^.*/--\0/g <bar> :nohlsearch <CR>
autocmd BufRead *.hs vnoremap <buffer><localleader>i :s/^--//g <bar> :nohlsearch <CR>

" no space between *.java,*m,*.h  
" comment
autocmd BufRead *.java,*.m,*.mm,*.h,*.cpp,*.c,*.php vnoremap <buffer><localleader>c :s/^\s*/\/\/\0/g <bar> :nohlsearch <CR>
autocmd BufRead *.java,*.m,*.mm,*.h,*.cpp,*.c,*.php vnoremap <buffer><localleader>i :s/^\/\///g      <bar> :nohlsearch <CR>
autocmd BufRead *.html cabbr sp :.,$s/<C-R><C-W>/<span style="color:#FF9933;">\0<\/span>/gc                <bar> :nohlsearch <CR>
autocmd BufRead *.html abbr  scode <a href="https://github.com/bsdshell/xcode/tree/master/TableViewCellApp/EmptyApp">source code</a> <CR>
" pandoc convert markdown to html and open the html file on browser
autocmd BufRead *.md   cabbr  mdd  :!pandoc % -f markdown -t html -s -o /tmp/test1.html <CR> :!open /tmp/test1.html <CR>

autocmd BufRead *.html abbr im <div class="cen"> 
                          \<CR><img src="../image/rotatedarrayfigure.svg" width="50%" height="50%" /><br> 
                          \<CR></div>

abbr re \color{red}
abbr ep </span>

cabbr todo :e ~/myfile/todo/todo.txt 
cabbr note :e ~/myfile/github/note/note.txt 
cabbr sess :mksession! ~/.vim/session/sess.vim 
cabbr me :g/[-+]\s*(\w\+\s*\*\?)\s*\w\+/z#.1

" source vimrc 
cabbr svim :source ~/.vimrc
" edit vimrc
cabbr vc :e ~/.vimrc 

" edit Haskell color scheme
cabbr hc :e ~/.vim/colors/haskellcolor.vim

" edit bashrc
cabbr bas :e ~/.bashrc


iabbr xblo NSString* (^myBlock)(int) = ^(int num) { <CR>   return num*num; <CR>};
iabbr xpp [path moveToPoint:CGPointMake(location.x, location.y)];<CR>[path addLineToPoint:CGPointMake(location.x + width, location.y)];<CR>[path addLineToPoint:CGPointMake(location.x + width, location.y + height)];<CR>[path addLineToPoint:CGPointMake(location.x, location.y + height)];<CR>[path addLineToPoint:CGPointMake(location.x, location.y)];
iabbr xcc blackColor <CR>darkGrayColor <CR>lightGrayColor<CR>whiteColor<CR>grayColor<CR>redColor<CR>greenColor<CR>blueColor<CR>cyanColor<CR>yellowColor<CR>magentaColor<CR>orangeColor<CR>purpleColor<CR>brownColor<CR>clearColor
iabbr kkk ListMonth()

iabbr ns NSLog(@"%s", __PRETTY_FUNCTION__);
iabbr crr \<CR>
iabbr par System.out.println("[" + height + "][" + width + "]");
iabbr tt3 public static void test3()<CR>{<CR>}
iabbr tt2 public static void test2()<CR>{<CR>}
iabbr tt1 public static void test1()<CR>{<CR>}
iabbr pp System.out.println("string ");
iabbr mn String name = new Object(){}.getClass().getEnclosingMethod().getName();<CR>System.out.println("{"+name + "}");
iabbr 2ari int[][] arr = { {1, 2, 3},<CR>{4, 5, 6},<CR>{7, 8, 9}<CR>};
iabbr 1ari int[] arr1 = {1, 4, 9};
iabbr 2ar int height = 1; <CR>int width = 2;<CR>int[][] = new int[height][width];
iabbr forr for(int i=0; i<array.length; i++)<CR>System.out.println("[" + i + "]=" + array[i]);
iabbr pub public static void print(int[][] arr, int height, int width)
iabbr bb <br>
iabbr spc <span style="color:#FFF; background:#000;border-radius:3px; padding:2px;">

autocmd BufRead *.html iabbr tab <table><CR><tbody><CR><tr><CR><td>Jim</td><CR><td>00001</td><CR><td>Blue</td><CR></tr><CR><tr><CR><td>Sue</td><CR><td>00002</td><CR><td>Red</td><CR></tr><CR><tr><CR><td>Barb</td><CR><td>00003</td><CR><td>Green</td><CR></tr><CR></tbody><CR></table>

iabbr divv <div style="text-align:center"><CR></div>


"[:h map-expression] [:h repeat]
iabbr <expr> gi  '<code data-gist-id="49533cf8014ea9b2eb34"></code>' .  "\<Esc>" . repeat('h', 30) 
iabbr <expr> ee  '\[   \]' .  "\<Esc>" . repeat('h', 4) 
iabbr <expr> txx '\text{}' . "\<Esc>" . repeat('h', 2)
iabbr <expr> fraa '\frac{}{}' . "\<Esc>" . repeat('h', 4)
iabbr <expr> dt   '<div style="color:red;font-size:18px;">' . strftime("%c") . '</div><br>'


iabbr gro $(\mathbb{N}, +)$
iabbr cml <p><CR>$\Large \color{red}\lambda$ 
        \<CR>Rename file name of default screenshots in Mac OSX, Open your Terminal and type:<br><br>
        \<CR><span style="color:#FFF; background:#000;border-radius:3px; padding:2px;">  
        \<CR>defaults write com.apple.screencapture name "myName"<br>
        \<CR></span><br>
        \<CR>And type:<br><br>
        \<CR><span style="color:#FFF; background:#000;border-radius:3px; padding:2px;">  
        \<CR>killall SystemUIServer
        \<CR></span> 
        \<CR></p>

iabbr grl \[
        \<CR>\alpha        \theta                  \tau       \\ 
        \<CR>\beta         \vartheta    \pi          \upsilon \\ 
        \<CR>\gamma        \gamma       \varpi       \phi     \\ 
        \<CR>\delta        \kappa       \rho         \varphi  \\ 
        \<CR>\epsilon      \lambda      \varrho      \chi     \\ 
        \<CR>\varepsilon   \mu          \sigma       \psi     \\ 
        \<CR>\zeta         \nu          \varsigma    \omega   \\ 
        \<CR>\eta          \xi                                \\ 
        \<CR>                                                 \\ 
        \<CR>\Gamma        \Lambda      \Sigma       \Psi     \\ 
        \<CR>\Delta                  \Upsilon     \Omega      \\ 
        \<CR>\Theta        \Pi          \Phi
        \<CR>\]
iabbr grtau $\Huge \color{red}\tau$ 
iabbr lmapq $\phi: \mathbb{Q} \rightarrow \mathbb{Q}$  
iabbr lmapr $\phi: \polyringr{x} \rightarrow  \polyringr{x}$ 
iabbr lmapn $\phi: \polyringn{x} \rightarrow  \polyringn{x}$ 
iabbr lmapc $\phi: \mathbb{C} \rightarrow \mathbb{C}$  

iabbr ma \begin{bmatrix}
        \<CR>1 & 2  & 3 \\
        \<CR>4 & 5  & 6 \\
        \<CR>7 & 8  & 9 \\
        \<CR>\end{bmatrix}

iabbr blo NSString* (^myBlock)(int) = ^(int num) { 
        \<CR>   return num*num; 
        \<CR>};

iabbr xpp [path moveToPoint:CGPointMake(location.x, location.y)];
        \<CR>[path addLineToPoint:CGPointMake(location.x + width, location.y)];
        \<CR>[path addLineToPoint:CGPointMake(location.x + width, location.y + height)];
        \<CR>[path addLineToPoint:CGPointMake(location.x, location.y + height)];
        \<CR>[path addLineToPoint:CGPointMake(location.x, location.y)];

iabbr xcc blackColor 
        \<CR>darkGrayColor 
        \<CR>lightGrayColor
        \<CR>whiteColor
        \<CR>grayColor
        \<CR>redColor
        \<CR>greenColor
        \<CR>blueColor
        \<CR>cyanColor
        \<CR>yellowColor
        \<CR>magentaColor
        \<CR>orangeColor
        \<CR>purpleColor
        \<CR>brownColor
        \<CR>clearColor

iabbr timm [NSTimer scheduledTimerWithTimeInterval:self.delayInterval
        \<CR>target:self
        \<CR>selector:@selector(suspendDisplay:)<CR>userInfo:nil<CR>repeats:NO];<CR><CR>-(void)suspendDisplay:(NSTimer*)timer{<CR>}

iabbr imav UIImageView* _imageView; 
                    \<CR>@property (nonatomic, retain) UIImageView* imageView;
                    \<CR>@synthesize imageView = _imageView;
                    \<CR>self.imageView = [[UIImageView alloc]initWithFrame:self.window.bounds];
                    \<CR>self.imageView.image=[UIImage imageNamed:@"myimage.jpg"];
                    \<CR>[self.window addSubview:self.imageView];

iabbr labb UILabel *myLabel = [[UILabel alloc] initWithFrame:CGRectMake(50, 50, 300, 300)];
                \<CR>[myLabel setTextColor:[UIColor redColor]];
                \<CR>[myLabel setBackgroundColor:[UIColor clearColor]];
                \<CR>[myLabel setFont:[UIFont fontWithName: @"Trebuchet MS" size: 20.0f]];
                \<CR>[myLabel setText:@"Supper Simple Application"];
                \<CR>[self.window addSubview:myLabel];
iabbr xss [%S]
iabbr xdd [%d]
iabbr xff [%f]
iabbr nsa NSLog(@"num1=[%f] num2=[%f]", num1, num2); <CR>NSLog(@"num1=[%d] num2=[%d]", num1, num2); 
iabbr nsd NSLog(@"num1=[%d] num2=[%d]", num1, num2); 
iabbr nsf NSLog(@"num1=[%f] num2=[%f]", num1, num2); 

" searchkey 
iabbr skk // searchkey:

autocmd FileType tex map  <F10> :!pdflatexlatex % <CR> :!open -a /Applications/Adobe\ Acrobat\ Reader\ DC.app/Contents/MacOS/AdobeReader matrix.pdf <CR>

" BufRead is better than FileType
autocmd BufRead *.m,*.h cabbr ttd :call Test(@")<CR>
autocmd BufRead *.m,*.h cabbr fff :call Defun()<CR>
autocmd BufRead *.m,*.h cabbr ffv :call DeVariable()<CR>
autocmd BufRead *.m,*.h cabbr ffu :call FindFun()<CR>
autocmd BufRead *.m,*.h cabbr ffr :call RemoveDuplicatedTabs()<CR>
autocmd BufRead *.m,*.h cabbr gg  :call HeaderSource()<CR>

augroup END 

"compile latex
"map  <F10> :!pdflatex % <CR> :!open -a /Applications/Adobe\ Acrobat\ Reader\ DC.app/Contents/MacOS/AdobeReader idea.pdf <CR>

"-----------------------------------------------------------------
" display git branch in statusline

function! GitBranch()
    let branch = system('git branch')
    let list = split(branch, "\n")
    let blist = []
    for bra in list
        if match(bra, '\* \w\+') != -1
            let blist = split(bra, " ")
        endif
    endfor
    if len(blist) > 1 
        return blist[1]
    else
        return ""
endfunction

"-----------------------------------------------------------------
" map and unmap keys

let g:keymap = 0 
function! MapKey()
    if g:keymap == 0 
        :map <F7> :vertical res +5 <CR>
        :map <F8> :vertical res -5 <CR>

        :map <F1> :tabp <CR> 
        :map <F2> :tabn <CR> 
        :map <F3> :tabnew <CR>

        :imap <F1> <Esc> :tabp <CR> 
        :imap <F2> <Esc> :tabn <CR> 

        :map <S-F10> :call ToggleColorScheme() <CR> 

        echo "map F7 +5  F8 -5"
        echo "map F1 :tabp  F2 :tabn F3 :tabnew"
        echo "map <S-F10> :call ToggleColorScheme()"

        let g:keymap = 1
    else
        :map <F7> <Nop>
        :map <F8> <Nop>

        :map <F1> <Nop> 
        :map <F2> <Nop> 
        :map <F3> <Nop>

        :imap <F1> <Nop>
        :imap <F2> <Nop>

        :map <S-F10> <Nop>

        
        echo "nunmap my key"

        let g:keymap = 0
    endif
endfunction

"-----------------------------------------------------------------
function! CloseWin()
    "let fname = expand("%:p")
    let fname = "/private/tmp/12345.x"
    echo fname
    if fname == "/private/tmp/12345.x"
        exec ":close" 
        exec "bdelete " . fname 
        if delete(fname) == 0
            echo "delte file:". fname
        else
            echo "delte file:" . fname . " failed"
        endif
    endif
endfunction

function! BufList()
  "let tmpname = tempname() 
  let tmpname =  "/private/tmp/12345.x" 
  let bufcount = bufnr("$")
  let currbufnr = 1
  let nummatches = 0
  let buflist = []
  let fnamelist = []
  let firstmatchingbufnr = 0
  while currbufnr <= bufcount
    if bufexists(currbufnr) != 0 
      let currbufname = bufname(currbufnr)
        "call add(buflist, currbufname)
        let nummatches += 1
        let firstmatchingbufnr = currbufnr
        let namelist = []
        if buflisted(currbufname) && strlen(currbufname) > 0
            let namelist = split(currbufname, "/")
            let fullbuffer = currbufnr . ": ". namelist[len(namelist)-1]
            call add(fnamelist, fullbuffer)
            "call add(fnamelist, currbufname)
        endif

    endif
    let currbufnr = currbufnr + 1
  endwhile
  :call writefile(fnamelist, tmpname, "a")
  echo tmpname
  exec "set splitright"
  exec "vsplit " . tmpname 
  exec "set nu!"
  exec "vertical resize 30"
  
endfunction
"-----------------------------------------------------------------
function! BufSel(pattern)
  let bufcount = bufnr("$")
  let currbufnr = 1
  let nummatches = 0
  let firstmatchingbufnr = 0
  while currbufnr <= bufcount
    if(bufexists(currbufnr))
      let currbufname = bufname(currbufnr)
      if(match(currbufname, a:pattern) > -1)
        echo currbufnr . ": ". bufname(currbufnr)
        let nummatches += 1
        let firstmatchingbufnr = currbufnr
      endif
    endif
    let currbufnr = currbufnr + 1
  endwhile
  if(nummatches == 1)
    execute ":buffer ". firstmatchingbufnr
  elseif(nummatches > 1)
    let desiredbufnr = input("Enter buffer number: ")
    if(strlen(desiredbufnr) != 0)
      execute ":buffer ". desiredbufnr
    endif
  else
    echo "No matching buffers"
  endif
endfunction

"Bind the BufSel() function to a user-command
command! -nargs=1 Bs :call BufSel("<args>")
"-----------------------------------------------------------------


"-----------------------------------------------------------------
" Fix the missing -cp option in java
" Assume java file is in current buffer
function! CompileJava()
    let path = expand("%")
    exec ":!javac " . path 
    let jclassName = expand("%:p:t:r")
    let cwd = getcwd()
    let full = ":!java -cp " . cwd . ":. " . jclassName
    exec  full 
endfunction 
"-----------------------------------------------------------------
function! CompileHaskell()
    let path = expand("%")
    exec ":!runhaskell " . path 
endfunction 
"-----------------------------------------------------------------
" Change solarized color scheme background light/dark
function! ToggleColorScheme()
          let s:currColor = g:colors_name  
          echo "color scheme=" . s:currColor
          if s:currColor == "solarized"
            let s:bg = synIDattr(synIDtrans(hlID("Normal")), "bg")
            echo "color=" . s:bg
            if s:bg == "#002b36"
                echo "Change color to #fdf6e3"
                exec 'hi Normal		guibg=' .  "#fdf6e3"
            else
                echo "Change color to #002b36"
                exec 'hi Normal		guibg=' .  "#002b36"
            endif
          endif
endfunction
"-----------------------------------------------------------------
" set background color, it only works for Terminal, not for GUI
let g:colorCode = synIDattr(hlID("Normal"), "bg#") 
if g:colorCode == -1
    let g:colorCode = 187
endif
function! IncreaseColor()
    if g:colorCode < 256 
        let g:colorCode = g:colorCode + 1
        exec 'hi Normal guifg=yellow	guibg=white ctermfg=black ctermbg=' .  g:colorCode
    endif
        echo 'hi Normal guifg=yellow	guibg=white ctermfg=black ctermbg=' .  g:colorCode
endfunction
function! DecreaseColor()
    if g:colorCode > 0
        let g:colorCode = g:colorCode - 1
        exec 'hi Normal		guifg=yellow	guibg=white ctermfg=black ctermbg=' .  g:colorCode
    endif
        echo 'hi Normal		guifg=yellow	guibg=white ctermfg=black ctermbg=' .  g:colorCode
endfunction
"-----------------------------------------------------------------

func! CurTabFileName( ) 
  return fnamemodify(bufname(winbufnr(tabpagewinnr(0))),':t') 
endfun 

function! SortBuffer()
    for i in range(tabpagenr('$'),1, -1)
        for j in range(1, i-1)
            " goto the first tab
            :tabr
            let curTab = CurTabFileName()
            :tabn
            let nextTab = CurTabFileName()

            if curTab > nextTab 
                :tabp
                exec ":tabmove " . j
            endif
        endfor
    endfor
endfunction


function! RemoveDuplicatedTabs()
    let NONAME = "NO_NAME"
    let invertDict = {}
    for i in range(tabpagenr('$'),1, -1)
        let curTab = CurTabFileName()
        if curTab == "" 
            let curTab = NONAME 
        endif

        let invertDict[i] = curTab 
        :tabn
    endfor

    let tabOffset = 0
    let newDict = {}
    for tabNum in sort(keys(invertDict))
        let tabName = get(invertDict, tabNum)
        let isDupNum = get(newDict, tabName)

        if isDupNum == 0 
            let newDict[tabName] = 1
        else
            let newTabNum = tabNum - tabOffset
            echo "===================== tabclose " . newTabNum . "  " .tabName
            exec ":tabclose! " . newTabNum 
            let tabOffset = tabOffset + 1
        endif
    endfor
    call SortBuffer()
endfunction



function! HeaderSource()
    let s:count   = line(".")
    let extension = expand("%:e")
    let fsource   = expand("%:p:r") . ".m"
    let fheader   = expand("%:p:r") . ".h"
    echo fsource
    if extension == "h" 
        execute "edit +" . s:count . " " . fsource 
    elseif extension == "m"
        execute "edit +" . s:count . " " . fheader
    endif
endfunction

" generate test template from register @"
function! Test(title)
    let input = a:title
    let list = matchlist(input, '\(+\|-\)([^)]*)\zs[^:]*')
    echo list 
    let comment = substitute(input, "{", "", "g")
    let output = "-(void)test_" . list[0] . "{\n\t//" . comment . "\n}\n"
    echo output 
    let @0 = output
    execute "put 0"
endfunction


function! DeVariable()
    let input = expand("<cword>") 
    " Get all the curr buffer #
    let all = range(0, bufnr('$'))
    let res = []
    for bn in all
        let name = bufname(bn) 

        " expand full path
        let fullpath = expand("%:p:r") . ".h"
        let s:count=0
        for line in readfile(fullpath) 
            if line =~ input 
                execute "edit +" . s:count . " " . fullpath 
                return 
            endif
            let s:count = s:count + 1 
        endfor
    endfor
endfunction

function! FindFun()
    let input = expand("<cword>") 
    " Get all the curr buffer #
    let all = range(0, bufnr('$'))
    for bn in all
        let fullName = bufname(bn)
        let name = fnamemodify(fullName, ":t")
        let curName = expand("%:p:t")
        
        " match file name [*.m]
        if  name != curName && name =~ '\(\~\|\/\|\w\|\d\)\+\.m'
            let s:count=0
            for line in readfile(fullName) 

                " match method defintion in ObjectiveC 
                "if line =~ '^\s*\(+\|-\)\s*(\(\*\|\w\)\+)'. input 
                if line =~ input 
                    execute "edit +" . s:count . " " . fullName 
                    return 
                endif
                let s:count = s:count + 1 
            endfor
        endif
    endfor
endfunction


function! Defun()
    let input = expand("<cword>") 
    " Get all the curr buffer #
    let all = range(0, bufnr('$'))
    for bn in all
        let name = bufname(bn) 
        " match file name [*.m]
        if name =~ '\(\~\|\/\|\w\|\d\)\+\.m' 
            let s:count=1
            for line in readfile(name) 

                " match method defintion in ObjectiveC 
                if line =~ '^\s*\(+\|-\)\s*(\(\*\|\w\)\+)'. input 
                    execute "edit +" . s:count . " " . name
                    return 
                endif
                let s:count = s:count + 1 
            endfor
        endif
    endfor
endfunction


" Vim >= 7.0 specific colors
if version >= 700
  hi CursorLine guibg=#2d2d2d
  hi CursorColumn guibg=#2d2d2d
  hi MatchParen guifg=#f6f3e8 guibg=#857b6f gui=bold
  hi Pmenu 		guifg=#f6f3e8 guibg=#444444
  hi PmenuSel 	guifg=#000000 guibg=#cae682
endif

"follwoing color will overwrite the colorscheme
" General colors
"hi Cursor 		guifg=NONE    guibg=#656565 gui=none
"hi Normal 		guifg=#f6f3e8 guibg=#242424 gui=none
"hi NonText 		guifg=#808080 guibg=#303030 gui=none
"hi LineNr 		guifg=#857b6f guibg=#000000 gui=none
"hi StatusLine 	guifg=#f6f3e8 guibg=#444444 gui=italic
"hi StatusLineNC guifg=#857b6f guibg=#444444 gui=none
"hi VertSplit 	guifg=#444444 guibg=#444444 gui=none
"hi Folded 		guibg=#384048 guifg=#a0a8b0 gui=none
"hi Title		guifg=#f6f3e8 guibg=NONE	gui=bold
"hi Visual		guifg=#f6f3e8 guibg=#444444 gui=none
"hi SpecialKey	guifg=#808080 guibg=#343434 gui=none

" Syntax highlighting
"hi Comment 		guifg=#99968b gui=italic
"hi Todo 		guifg=#8f8f8f gui=italic
"hi Constant 	guifg=#e5786d gui=none
"hi String 		guifg=#95e454 gui=italic
"hi Identifier 	guifg=#cae682 gui=none
"hi Function 	guifg=#cae682 gui=none
"hi Type 		guifg=#cae682 gui=none
"hi Statement 	guifg=#8ac6f2 gui=none
"hi Keyword		guifg=#8ac6f2 gui=none
"hi PreProc 		guifg=#e5786d gui=none
"hi Number		guifg=#e5786d gui=none
"hi Special		guifg=#e7f6da gui=none
